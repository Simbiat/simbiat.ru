<?php
declare(strict_types = 1);

namespace Simbiat\Website;

use DeviceDetector\ClientHints;
use DeviceDetector\DeviceDetector;
use DeviceDetector\Parser\AbstractParser;
use DeviceDetector\Parser\Device\AbstractDeviceParser;

use Simbiat\Database\Query;
use Simbiat\http20\IRI;
use function is_array, function_exists;

/**
 * Various security stuff
 */
class Security
{
    public const string eMailRegex = '/^[a-zA-Z0-9.!#$%&â€™*+\/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/';
    
    /**
     * Function to hash password. Used mostly as a wrapper in case of future changes
     * @param string $password
     *
     * @return string
     */
    public static function passHash(#[\SensitiveParameter] string $password): string
    {
        return password_hash($password, PASSWORD_ARGON2ID, Config::$argonSettings);
    }
    
    /**
     * Function to encrypt stuff.
     *
     * **DO NOT use for permanent data storage**
     * @param string $data
     *
     * @return string
     */
    public static function encrypt(#[\SensitiveParameter] string $data): string
    {
        if (empty($data)) {
            return '';
        }
        #Generate IV
        $iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length('AES-256-GCM'));
        #This is where the tag will be written by OpenSSL
        $tag = '';
        #Ecnrypt and als get the tag
        $encrypted = openssl_encrypt($data, 'AES-256-GCM', hex2bin($_ENV['ENCRYPTION_PASSPHRASE']), OPENSSL_RAW_DATA, $iv, $tag);
        #Ecnrypt and prepend IV and tag
        return base64_encode($iv.$tag.$encrypted);
    }
    
    /**
     * Function to decrypt stuff
     * @param string $data
     *
     * @return string
     */
    public static function decrypt(string $data): string
    {
        if (empty($data)) {
            return '';
        }
        #Decode
        $data = base64_decode($data);
        #Get IV
        $iv = substr($data, 0, 12);
        #Get tag
        $tag = substr($data, 12, 16);
        #Strip them from data
        $data = substr($data, 28);
        return openssl_decrypt($data, 'AES-256-GCM', hex2bin($_ENV['ENCRYPTION_PASSPHRASE']), OPENSSL_RAW_DATA, $iv, $tag);
    }
    
    /**
     * Function to generate tokens (for example, CSRF)
     * @return string
     */
    public static function genToken(): string
    {
        try {
            $token = bin2hex(random_bytes(32));
        } catch (\Throwable) {
            $token = '';
        }
        @header('X-CSRF-Token: '.$token);
        return $token;
    }
    
    /**
     * Function to calculate optimal parameters for Argon2 hashing (password used is just a random test one) or return existing ones.
     * Clarification for whoever reads this: while it is recommended to first allocate as much memory as possible and then increase the number of iterations, if this logic is applied to a high-load web-server, it will become highly likely to get the memory exhaustion during concurrent runs of the validation. Thus, this automated function first calculates the number of iterations and then memory.
     * This does not necessarily mean a reduction of security, but if you feel unsafe, adjust the setting file generated by this function to settings that work better for you. Keep in mind, that amount of memory is recommended to be a value of power of 2 (1024 is the minimum one).
     * Time of 0.005 seems a good middle ground to keep average to allow a speedy webpages load (with ~500-600 ms on pages that are relatively small, but do have some computation)
     *
     * @param bool   $forceRefresh Force update of values
     * @param float  $maxTimeSpent Amount of time we are ok to spend
     * @param string $stringToTest Test string to test the time
     *
     * @return array
     */
    public static function argonCalc(bool $forceRefresh = false, float $maxTimeSpent = 0.005, string $stringToTest = 'rel@t!velyl0ngte$t5tr1ng'): array
    {
        #Load Argon settings if argon.json exists
        if (!$forceRefresh && is_file(Config::$securitySettings)) {
            #Read the file
            $argon = json_decode(file_get_contents(Config::$securitySettings), true);
            if (is_array($argon)) {
                #Update settings, if they are present and comply with minimum requirements
                if (!isset($argon['memory_cost']) || $argon['memory_cost'] < 1024) {
                    $argon['memory_cost'] = 1024;
                }
                if (!isset($argon['time_cost']) || $argon['time_cost'] < 1) {
                    $argon['time_cost'] = 1;
                }
                if (!isset($argon['threads']) || $argon['threads'] < 1) {
                    $argon['threads'] = 1;
                }
                return $argon;
            }
        }
        #Calculate the number of available threads
        $threads = self::countCores();
        #Calculate iterations
        $iterations = 0;
        do {
            $iterations++;
            $start = microtime(true);
            password_hash($stringToTest, PASSWORD_ARGON2ID, ['threads' => $threads, 'time_cost' => $iterations]);
            $end = microtime(true);
        } while (($end - $start) <= $maxTimeSpent);
        #Calculate memory. We start from power = 9, because Argon supports a minimum value of 1024 (power = 10)
        $power = 9;
        do {
            $power++;
            $memory = 2 ** $power;
            $start = microtime(true);
            password_hash($stringToTest, PASSWORD_ARGON2ID, ['threads' => $threads, 'time_cost' => $iterations, 'memory_cost' => $memory]);
            $end = microtime(true);
        } while (($end - $start) <= $maxTimeSpent);
        $argonSettings = ['threads' => $threads, 'time_cost' => $iterations, 'memory_cost' => $memory];
        #Write a config file
        file_put_contents(Config::$securitySettings, json_encode($argonSettings, JSON_PRETTY_PRINT));
        return $argonSettings;
    }
    
    /**
     * Helper function to get count of available cores
     * @return int
     */
    private static function countCores(): int
    {
        if (function_exists('shell_exec')) {
            $cores = (int)shell_exec((PHP_OS_FAMILY === 'Windows' ? 'echo %NUMBER_OF_PROCESSORS%' : 'nproc'));
        } else {
            $cores = 1;
        }
        if ($cores < 1) {
            $cores = 1;
        }
        return $cores;
    }
    
    /**
     * Function to generate passphrase for encrypt and decrypt functions
     * @return string
     */
    public static function genCrypto(): string
    {
        return bin2hex(openssl_random_pseudo_bytes(openssl_cipher_iv_length('AES-256-GCM')));
    }
    
    /**
     * Function to log actions
     * @param string     $type   Action type
     * @param string     $action Message of the action
     * @param mixed|null $extras Extra data related to the action
     * @param int|null   $userid User ID of the user that triggered the action
     *
     * @return bool
     */
    public static function log(string $type, string $action, mixed $extras = NULL, ?int $userid = null): bool
    {
        if (!empty($extras) && !\is_scalar($extras)) {
            $extras = json_encode($extras, JSON_PRETTY_PRINT | JSON_INVALID_UTF8_SUBSTITUTE | JSON_UNESCAPED_UNICODE | JSON_PRESERVE_ZERO_FRACTION);
        }
        #Get IP
        $ip = $_SESSION['IP'] ?? null;
        #Get username
        $userid = $_SESSION['userid'] ?? $userid ?? Config::userIDs['Unknown user'];
        #Get User Agent
        $ua = $_SESSION['UA']['full'] ?? null;
        try {
            Query::query(
                'INSERT INTO `sys__logs` (`time`, `type`, `action`, `userid`, `ip`, `useragent`, `extra`) VALUES (CURRENT_TIMESTAMP(), (SELECT `typeid` FROM `sys__log_types` WHERE `name`=:type), :action, :userid, :ip, :ua, :extras);',
                [
                    ':type' => $type,
                    ':action' => $action,
                    ':userid' => [$userid, 'int'],
                    ':ip' => [
                        (empty($ip) ? NULL : $ip),
                        (empty($ip) ? 'null' : 'string'),
                    ],
                    ':ua' => [
                        (empty($ua) ? NULL : $ua),
                        (empty($ua) ? 'null' : 'string'),
                    ],
                    ':extras' => [
                        (empty($extras) ? NULL : $extras),
                        (empty($extras) ? 'null' : 'string'),
                    ],
                ]
            );
            return true;
        } catch (\Throwable $exception) {
            #Log to the file. Generally we do not lose much if this fails
            Errors::error_log($exception);
            return false;
        }
    }
    
    /**
     * Get Bot name, OS and Browser for user agent
     * @return array
     */
    public static function getUA(): array
    {
        #Check if User Agent is present
        if (empty($_SERVER['HTTP_USER_AGENT'])) {
            #Something is fishy, so let's 418 this
            return ['unsupported' => true, 'browser' => false];
        }
        #Force full string versions
        AbstractDeviceParser::setVersionTruncation(AbstractParser::VERSION_TRUNCATION_NONE);
        #Initialize device detector
        $dd = (new DeviceDetector($_SERVER['HTTP_USER_AGENT'], ClientHints::factory($_SERVER)));
        $dd->parse();
        #Get bot name
        $bot = $dd->getBot();
        if (is_array($bot)) {
            #Do not waste resources on bots
            return ['bot' => mb_substr($bot['name'], 0, 64, 'UTF-8'), 'os' => NULL, 'client' => NULL, 'unsupported' => false, 'browser' => false];
        }
        #Get OS
        $os = $dd->getOs();
        #Concat OS and version
        $os = mb_trim(($os['name'] ?? '').' '.($os['version'] ?? ''), null, 'UTF-8');
        #Force OS to be NULL if it's empty
        if (empty($os)) {
            $os = NULL;
        }
        #Get client
        $browser = $dd->isBrowser();
        $client = $dd->getClient();
        #Check if a client is supported
        if (preg_match('/^(Internet Explorer|Opera Mini|Opera Mobile|Baidu|UC Browser|QQ Browser|KaiOS Browser)/ui', $client['name'] ?? '') === 1 ||
            (!empty($client['version']) && (
                    #Safari started supporting Sec-Fetch from 16.4
                    (preg_match('/^(Safari)/ui', $client['name'] ?? '') === 1 && version_compare(mb_strtolower($client['version'], 'UTF-8'), '16.4', 'lt')) ||
                    #Similar to Chrome and Edge, but full support started from 80
                    (preg_match('/^(Chrome)/ui', $client['name'] ?? '') === 1 && version_compare(mb_strtolower($client['version'], 'UTF-8'), '80.0', 'lt')) ||
                    (preg_match('/^(Edge)/ui', $client['name'] ?? '') === 1 && version_compare(mb_strtolower($client['version'], 'UTF-8'), '80.0', 'lt')) ||
                    #Version 90 for Firefox
                    (preg_match('/^(Firefox)/ui', $client['name'] ?? '') === 1 && version_compare(mb_strtolower($client['version'], 'UTF-8'), '90.0', 'lt')) ||
                    #Version 67 for Opera
                    (preg_match('/^(Opera)/ui', $client['name'] ?? '') === 1 && version_compare(mb_strtolower($client['version'], 'UTF-8'), '67.0', 'lt'))
                ))
        ) {
            $unsupported = true;
        } else {
            $unsupported = false;
        }
        #Concat client and version
        $client = mb_trim(($client['name'] ?? '').' '.($client['version'] ?? ''), null, 'UTF-8');
        #Force the client to be NULL if it's empty
        if (empty($client)) {
            $client = NULL;
        }
        return ['bot' => NULL, 'os' => ($os !== NULL ? mb_substr($os, 0, 100, 'UTF-8') : NULL), 'client' => ($client !== NULL ? mb_substr($client, 0, 100, 'UTF-8') : NULL), 'full' => $_SERVER['HTTP_USER_AGENT'], 'unsupported' => $unsupported, 'browser' => $browser];
    }
    
    /**
     * Sanitize URLs and remove tracking query parameters from them
     * @param string $url
     *
     * @return string
     */
    public static function sanitizeURL(string $url): string
    {
        #First, normalize the string
        $url = \Normalizer::normalize($url, \Normalizer::FORM_C);
        #Check if valid IRI
        if (!IRI::isValidIri($url, 'https')) {
            return '';
        }
        #Attempt to parse it
        $parsedUrl = IRI::parseUri($url);
        #Ignore failed strings
        if (!is_array($parsedUrl)) {
            return '';
        }
        #Parse the query string into an associative array
        parse_str($parsedUrl['query'] ?? '', $queryParams);
        #Remove tracking parameters
        foreach ($queryParams as $param => $value) {
            if (\in_array($param, Config::$sharedWithJS['trackingQueryParameters'], true)) {
                unset($queryParams[$param]);
            }
        }
        #Rebuild the query string
        $parsedUrl['query'] = IRI::rawBuildQuery($queryParams);
        #Reconstruct the full URL
        return IRI::restoreUri($parsedUrl);
    }
}
