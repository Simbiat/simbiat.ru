<?php
declare(strict_types = 1);

namespace Simbiat\Website;

use DeviceDetector\ClientHints;
use DeviceDetector\DeviceDetector;
use DeviceDetector\Parser\AbstractParser;
use DeviceDetector\Parser\Device\AbstractDeviceParser;

use Simbiat\Database\Query;
use Simbiat\http20\IRI;
use function is_array, function_exists;

/**
 * Various security stuff
 */
class Security
{
    public const string EMAIL_REGEX = '/^[a-zA-Z0-9.!#$%&â€™*+\/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/u';
    
    /**
     * Function to hash password. Used mostly as a wrapper in case of future changes
     * @param string $password
     *
     * @return string
     */
    public static function passHash(#[\SensitiveParameter] string $password): string
    {
        return \password_hash($password, \PASSWORD_ARGON2ID, Config::$argon_settings);
    }
    
    /**
     * Function to encrypt stuff.
     *
     * **DO NOT use for permanent data storage**
     *
     * @param string $data
     *
     * @return string
     * @throws \Random\RandomException
     */
    public static function encrypt(#[\SensitiveParameter] string $data): string
    {
        if (empty($data)) {
            return '';
        }
        #Generate IV
        $iv = \random_bytes(\openssl_cipher_iv_length('AES-256-GCM'));
        #This is where the tag will be written by OpenSSL
        $tag = '';
        #Ecnrypt and als get the tag
        $encrypted = \openssl_encrypt($data, 'AES-256-GCM', \hex2bin($_ENV['ENCRYPTION_PASSPHRASE']), \OPENSSL_RAW_DATA, $iv, $tag);
        #Ecnrypt and prepend IV and tag
        return \base64_encode($iv.$tag.$encrypted);
    }
    
    /**
     * Function to decrypt stuff
     *
     * @param string $data
     *
     * @return string
     * @noinspection NoMBMultibyteAlternative
     */
    public static function decrypt(string $data): string
    {
        if (empty($data)) {
            return '';
        }
        #Decode
        $data = \base64_decode($data);
        #Get IV
        $iv = \substr($data, 0, 12);
        #Get tag
        $tag = \substr($data, 12, 16);
        #Strip them from data
        $data = \substr($data, 28);
        return \openssl_decrypt($data, 'AES-256-GCM', \hex2bin($_ENV['ENCRYPTION_PASSPHRASE']), \OPENSSL_RAW_DATA, $iv, $tag);
    }
    
    /**
     * Function to generate tokens (for example, CSRF)
     * @return string
     */
    public static function genToken(): string
    {
        try {
            $token = \bin2hex(\random_bytes(32));
        } catch (\Throwable) {
            $token = '';
        }
        if (!\headers_sent()) {
            \header('X-CSRF-Token: '.$token);
        }
        return $token;
    }
    
    /**
     * Function to calculate optimal parameters for Argon2 hashing (password used is just a random test one) or return existing ones.
     * Clarification for whoever reads this: while it is recommended to first allocate as much memory as possible and then increase the number of iterations, if this logic is applied to a high-load web-server, it will become highly likely to get the memory exhaustion during concurrent runs of the validation. Thus, this automated function first calculates the number of iterations and then memory.
     * This does not necessarily mean a reduction of security, but if you feel unsafe, adjust the setting file generated by this function to settings that work better for you. Keep in mind, that amount of memory is recommended to be a value of power of 2 (1024 is the minimum one).
     * Time of 0.005 seems a good middle ground to keep average to allow a speedy webpages load (with ~500-600 ms on pages that are relatively small, but do have some computation)
     *
     * @param bool   $force_refresh  Force update of values
     * @param float  $max_time_spent The amount of time we are ok to spend
     * @param string $string_to_test Test string to test the time
     *
     * @return array
     */
    public static function argonCalc(bool $force_refresh = false, float $max_time_spent = 0.005, string $string_to_test = 'rel@t!velyl0ngte$t5tr1ng'): array
    {
        #Load Argon settings if argon.json exists
        if (!$force_refresh && \is_file(Config::$security_settings)) {
            #Read the file
            $argon = \json_decode(\file_get_contents(Config::$security_settings), true);
            if (is_array($argon)) {
                #Update the settings if they are present and comply with minimum requirements
                if (!isset($argon['memory_cost']) || $argon['memory_cost'] < 1024) {
                    $argon['memory_cost'] = 1024;
                }
                if (!isset($argon['time_cost']) || $argon['time_cost'] < 1) {
                    $argon['time_cost'] = 1;
                }
                if (!isset($argon['threads']) || $argon['threads'] < 1) {
                    $argon['threads'] = 1;
                }
                return $argon;
            }
        }
        #Calculate the number of available threads
        $threads = self::countCores();
        #Calculate iterations
        $iterations = 0;
        do {
            $iterations++;
            $start = \microtime(true);
            #We do not store the results, and these are not real credentials, so suppressing the respective inspections
            /** @noinspection UnusedFunctionResultInspection */
            /** @noinspection HardcodedCredentialsInspection */
            \password_hash($string_to_test, \PASSWORD_ARGON2ID, ['threads' => $threads, 'time_cost' => $iterations]);
            $end = \microtime(true);
        } while (($end - $start) <= $max_time_spent);
        #Calculate memory. We start from power = 9, because Argon supports a minimum value of 1024 (power = 10)
        $power = 9;
        do {
            $power++;
            $memory = 2 ** $power;
            $start = \microtime(true);
            #We do not store the results, and these are not real credentials, so suppressing the respective inspections
            /** @noinspection UnusedFunctionResultInspection */
            /** @noinspection HardcodedCredentialsInspection */
            \password_hash($string_to_test, \PASSWORD_ARGON2ID, ['threads' => $threads, 'time_cost' => $iterations, 'memory_cost' => $memory]);
            $end = \microtime(true);
        } while (($end - $start) <= $max_time_spent);
        $argon_settings = ['threads' => $threads, 'time_cost' => $iterations, 'memory_cost' => $memory];
        #Write a config file
        \file_put_contents(Config::$security_settings, \json_encode($argon_settings, \JSON_PRETTY_PRINT));
        return $argon_settings;
    }
    
    /**
     * Helper function to get count of available cores
     * @return int
     */
    private static function countCores(): int
    {
        if (function_exists('shell_exec')) {
            $cores = (int)\shell_exec((\PHP_OS_FAMILY === 'Windows' ? 'echo %NUMBER_OF_PROCESSORS%' : 'nproc'));
        } else {
            $cores = 1;
        }
        if ($cores < 1) {
            $cores = 1;
        }
        return $cores;
    }
    
    /**
     * Function to generate passphrase for encrypt and decrypt functions
     *
     * @return string
     * @throws \Random\RandomException
     */
    public static function genCrypto(): string
    {
        $pass = \random_bytes(\openssl_cipher_iv_length('AES-256-GCM'));
        return \bin2hex($pass);
    }
    
    /**
     * Function to log actions
     * @param string     $type    Action type
     * @param string     $action  Message of the action
     * @param mixed|null $extras  Extra data related to the action
     * @param int|null   $user_id User ID of the user that triggered the action
     *
     * @return bool
     */
    public static function log(string $type, string $action, mixed $extras = NULL, ?int $user_id = null): bool
    {
        if (!empty($extras) && !\is_scalar($extras)) {
            $extras = \json_encode($extras, \JSON_PRETTY_PRINT | \JSON_INVALID_UTF8_SUBSTITUTE | \JSON_UNESCAPED_UNICODE | \JSON_PRESERVE_ZERO_FRACTION);
        }
        #Get IP
        $ip = $_SESSION['ip'] ?? null;
        #Get username
        $user_id = (int)($_SESSION['user_id'] ?? $user_id ?? Config::USER_IDS['Unknown user']);
        #Get User Agent
        $ua = $_SESSION['useragent']['full'] ?? null;
        try {
            Query::query(
                'INSERT INTO `sys__logs` (`time`, `type`, `action`, `user_id`, `ip`, `user_agent`, `extra`) VALUES (CURRENT_TIMESTAMP(), (SELECT `type_id` FROM `sys__log_types` WHERE `name`=:type), :action, :user_id, :ip, :ua, :extras);',
                [
                    ':type' => $type,
                    ':action' => $action,
                    ':user_id' => [$user_id, 'int'],
                    ':ip' => [
                        (empty($ip) ? NULL : $ip),
                        (empty($ip) ? 'null' : 'string'),
                    ],
                    ':ua' => [
                        (empty($ua) ? NULL : $ua),
                        (empty($ua) ? 'null' : 'string'),
                    ],
                    ':extras' => [
                        (empty($extras) ? NULL : $extras),
                        (empty($extras) ? 'null' : 'string'),
                    ],
                ]
            );
            return true;
        } catch (\Throwable $exception) {
            #Log to the file. Generally we do not lose much if this fails
            Errors::error_log($exception);
            return false;
        }
    }
    
    /**
     * Get Bot name, OS and Browser for user agent
     * @return array
     */
    public static function getUA(): array
    {
        #Check if User Agent is present
        if (empty($_SERVER['HTTP_USER_AGENT'])) {
            #Something is fishy, so let's 418 this
            return ['unsupported' => true, 'browser' => false];
        }
        #Force full string versions
        AbstractDeviceParser::setVersionTruncation(AbstractParser::VERSION_TRUNCATION_NONE);
        #Initialize device detector
        $dd = (new DeviceDetector($_SERVER['HTTP_USER_AGENT'], ClientHints::factory($_SERVER)));
        $dd->parse();
        #Get bot name
        $bot = $dd->getBot();
        if (is_array($bot)) {
            #Do not waste resources on bots
            /** @noinspection OffsetOperationsInspection https://github.com/kalessil/phpinspectionsea/issues/1941 */
            return ['bot' => mb_substr($bot['name'], 0, 64, 'UTF-8'), 'os' => NULL, 'client' => NULL, 'unsupported' => false, 'browser' => false];
        }
        #Get OS
        $os = $dd->getOs();
        #Concat OS and version
        $os = mb_trim(($os['name'] ?? '').' '.($os['version'] ?? ''), null, 'UTF-8');
        #Force OS to be NULL if it's empty
        if (empty($os)) {
            $os = NULL;
        }
        #Get client
        $browser = $dd->isBrowser();
        $client = $dd->getClient();
        #Check if a client is supported
        if (\preg_match('/^(Internet Explorer|Opera Mini|Opera Mobile|Baidu|UC Browser|QQ Browser|KaiOS Browser)/ui', $client['name'] ?? '') === 1 ||
            (!empty($client['version']) && (
                    #Safari started supporting Sec-Fetch from 16.4
                    (\preg_match('/^(Safari)/ui', $client['name'] ?? '') === 1 && \version_compare(mb_strtolower($client['version'], 'UTF-8'), '16.4', 'lt')) ||
                    #Similar to Chrome and Edge, but full support started from 80
                    (\preg_match('/^(Chrome)/ui', $client['name'] ?? '') === 1 && \version_compare(mb_strtolower($client['version'], 'UTF-8'), '80.0', 'lt')) ||
                    (\preg_match('/^(Edge)/ui', $client['name'] ?? '') === 1 && \version_compare(mb_strtolower($client['version'], 'UTF-8'), '80.0', 'lt')) ||
                    #Version 90 for Firefox
                    (\preg_match('/^(Firefox)/ui', $client['name'] ?? '') === 1 && \version_compare(mb_strtolower($client['version'], 'UTF-8'), '90.0', 'lt')) ||
                    #Version 67 for Opera
                    (\preg_match('/^(Opera)/ui', $client['name'] ?? '') === 1 && \version_compare(mb_strtolower($client['version'], 'UTF-8'), '67.0', 'lt'))
                ))
        ) {
            $unsupported = true;
        } else {
            $unsupported = false;
        }
        #Concat client and version
        $client = mb_trim(($client['name'] ?? '').' '.($client['version'] ?? ''), null, 'UTF-8');
        #Force the client to be NULL if it's empty
        if (empty($client)) {
            $client = NULL;
        }
        return ['bot' => NULL, 'os' => ($os !== NULL ? mb_substr($os, 0, 100, 'UTF-8') : NULL), 'client' => ($client !== NULL ? mb_substr($client, 0, 100, 'UTF-8') : NULL), 'full' => $_SERVER['HTTP_USER_AGENT'], 'unsupported' => $unsupported, 'browser' => $browser];
    }
    
    /**
     * Sanitize URLs and remove tracking query parameters from them
     * @param string $url
     *
     * @return string
     */
    public static function sanitizeURL(string $url): string
    {
        #First, normalize the string
        $url = \Normalizer::normalize($url, \Normalizer::FORM_C);
        #Check if valid IRI
        if (!IRI::isValidIri($url, 'https')) {
            return '';
        }
        #Attempt to parse it
        $parsed_url = IRI::parseUri($url);
        #Ignore failed strings
        if (!is_array($parsed_url)) {
            return '';
        }
        #Parse the query string into an associative array
        /** @noinspection OffsetOperationsInspection https://github.com/kalessil/phpinspectionsea/issues/1941 */
        \parse_str($parsed_url['query'] ?? '', $query_params);
        #Remove tracking parameters
        foreach ($query_params as $param => $value) {
            if (\in_array($param, Config::$shared_with_js['tracking_query_parameters'], true)) {
                unset($query_params[$param]);
            }
        }
        #Rebuild the query string
        /** @noinspection OffsetOperationsInspection https://github.com/kalessil/phpinspectionsea/issues/1941 */
        $parsed_url['query'] = IRI::rawBuildQuery($query_params);
        #Reconstruct the full URL
        return IRI::restoreUri($parsed_url);
    }
    
    /**
     * Wrapper for regular `session_regenerate_id`, to always include CSRF regeneration.
     * @param bool $delete_old_session Whether to delete the old associated session or not.
     *
     * @return bool
     */
    public static function session_regenerate_id(bool $delete_old_session = false): bool
    {
        try {
            \session_regenerate_id($delete_old_session);
            $_SESSION['csrf'] = self::genToken();
            return true;
        } catch (\Throwable) {
            return false;
        }
    }
}
