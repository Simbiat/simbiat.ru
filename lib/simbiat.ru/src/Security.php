<?php
declare(strict_types=1);
namespace Simbiat;

use Simbiat\Config\Common;
use Simbiat\Config\Talks;
use Symfony\Component\HtmlSanitizer\HtmlSanitizer;
use Symfony\Component\HtmlSanitizer\HtmlSanitizerConfig;

class Security
{

    #Static sanitizer config for a little bit performance
    public static ?HtmlSanitizerConfig $sanitizerConfig = null;

    #Function to hash password. Used mostly as a wrapper in case of future changes
    public static function passHash(string $password): string
    {
        return password_hash($password, PASSWORD_ARGON2ID, Config\Security::$argonSettings);
    }

    #Function to encrypt stuff
    public static function encrypt(string $data): string
    {
        if (empty($data)) {
            return '';
        }
        #Generate IV
        $iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length('AES-256-GCM'));
        #This is where tag will be written by OpenSSL
        $tag = '';
        #Ecnrypt and als get the tag
        $encrypted = openssl_encrypt($data, 'AES-256-GCM', hex2bin(Config\Security::$aesSettings['passphrase']), OPENSSL_RAW_DATA, $iv, $tag);
        #Ecnrypt and prepend IV and tag
        return base64_encode($iv.$tag.$encrypted);
    }

    #Function to decrypt stuff
    public static function decrypt(string $data): string
    {
        if (empty($data)) {
            return '';
        }
        #Decode
        $data = base64_decode($data);
        #Get IV
        $iv = substr($data, 0, 12);
        #Get tag
        $tag = substr($data, 12, 16);
        #Strip them from data
        $data = substr($data, 28);
        return openssl_decrypt($data, 'AES-256-GCM', hex2bin(Config\Security::$aesSettings['passphrase']), OPENSSL_RAW_DATA, $iv, $tag);
    }

    #Function to generate tokens (for example CSRF)
    public static function genToken(): string
    {
        try {
            $token = bin2hex(random_bytes(32));
        } catch (\Throwable) {
            $token = '';
        }
        @header('X-CSRF-Token: '.$token);
        return $token;
    }

    public static function sanitizeHTML(string $string, bool $head = false): string
    {
        #Check if config has been created already
        if (self::$sanitizerConfig) {
            $config = self::$sanitizerConfig;
        } else {
            $config = (new HtmlSanitizerConfig())->withMaxInputLength(-1)->allowSafeElements()->allowRelativeLinks()->allowMediaHosts([Common::$http_host])->allowRelativeMedias()->forceHttpsUrls()->allowLinkSchemes(['https', 'mailto'])->allowMediaSchemes(['https']);
            #Block some extra elements
            foreach (['aside', 'basefont', 'body', 'font', 'footer', 'form', 'header', 'hgroup', 'html', 'input', 'main', 'nav', 'option', 'ruby', 'select', 'selectmenu', 'template', 'textarea',] as $element) {
                #Need to update the original, because clone is returned, instead of the same instance.
                $config = $config->blockElement($element);
            }
            #Allow class attribute
            $config = $config->allowAttribute('class', '*');
            #Save config to static for future reuse
            self::$sanitizerConfig = $config;
        }
        #Allow some property attributes for meta tags
        if ($head) {
            $config = $config->allowAttribute('property', 'meta');
        }
        $sanitizer = new HtmlSanitizer($config);
        #Remove excessive new lines
        $string = preg_replace('/(^(<br \/>\s*)+)|((<br \/>\s*)+$)/mi', '', preg_replace('/(\s*<br \/>\s*){5,}/mi', '<br>', $string));
        if ($head) {
            return $sanitizer->sanitizeFor('head', $string);
        } else {
            return $sanitizer->sanitize($string);
        }
    }

    #Function to calculate optimal parameters for Argon2 hashing (password used is just a random test one) or return existing ones.
    #Clarification for whoever reads this: while it is recommended to first allocate as much memory as possible and then increase the number of iterations, if this logic is applied to a high-load web-server it will become highly likely to get the memory exhaustion during concurrent runs of the validation. Thus, this automated function first calculates the number of iterations and then memory.
    #This does not necessarily mean reduction of security, but if you feel unsafe, adjust the setting file generated by this function to settings that work better for you. Keep in mind, that amount of memory is recommended to be a value of power of 2 (1024 is the minimum one).
    public static function argonCalc(bool $forceRefresh = false): array
    {
        #Load Argon settings if argon.json exists
        if (is_file(Config\Common::$securityCache. '/argon.json') && !$forceRefresh) {
            #Read the file
            $argon = json_decode(file_get_contents(Config\Common::$securityCache. '/argon.json'), true);
            if (is_array($argon)) {
                #Update settings, if they are present and comply with minimum requirements
                if (!isset($argon['memory_cost']) || $argon['memory_cost'] < 1024) {
                    $argon['memory_cost'] = 1024;
                }
                if (!isset($argon['time_cost']) || $argon['time_cost'] < 1) {
                    $argon['time_cost'] = 1;
                }
                if (!isset($argon['threads']) || $argon['threads'] < 1) {
                    $argon['threads'] = 1;
                }
                return $argon;
            }
        }
        #Create directory if missing
        if (!is_dir(Common::$securityCache)) {
            mkdir(Common::$securityCache);
        }
        #Calculate number of available threads
        $threads = self::countCores()*2;
        #Calculate iterations
        $iterations = 0;
        do {
            $iterations++;
            $start = microtime(true);
            password_hash('rel@t!velyl0ngte$t5tr1ng', PASSWORD_ARGON2ID, ['threads' => $threads, 'time_cost' => $iterations]);
            $end = microtime(true);
        } while (($end - $start) < 1.0);
        #Calculate memory. We start from power = 9, because Argon supports minimum value of 1024 (power = 10)
        $power = 9;
        do {
            $power++;
            $memory = 2**$power;
            $start = microtime(true);
            password_hash('rel@t!velyl0ngte$t5tr1ng', PASSWORD_ARGON2ID, ['threads' => $threads, 'time_cost' => $iterations, 'memory_cost' => $memory]);
            $end = microtime(true);
        } while (($end - $start) < 1.0);
        $argonSettings = ['threads' => $threads, 'time_cost' => $iterations, 'memory_cost' => $memory];
        #Write config file
        file_put_contents(Common::$securityCache.'/argon.json', json_encode($argonSettings, JSON_PRETTY_PRINT));
        return $argonSettings;
    }

    #Helper function to get count of available cores
    private static function countCores(): int
    {
        if (function_exists('shell_exec') === true) {
            $cores = intval(shell_exec((PHP_OS_FAMILY === 'Windows' ? 'echo %NUMBER_OF_PROCESSORS%' : 'nproc')));
        } else {
            $cores = 1;
        }
        if ($cores < 1) {
            $cores = 1;
        }
        return $cores;
    }

    #Function to generate passphrase for encrypt and decrypt functions
    public static function genCrypto(bool $forceRefresh = false): array
    {
        if (is_file(Config\Common::$securityCache. '/aes.json') && !$forceRefresh) {
            $aes = json_decode(file_get_contents(Config\Common::$securityCache.'/aes.json'), true);
            if (is_array($aes)) {
                if (isset($aes['passphrase'])) {
                    return $aes;
                }
            }
        }
        #Create directory if missing
        if (!is_dir(Common::$securityCache)) {
            mkdir(Common::$securityCache);
        }
        $passphrase = bin2hex(openssl_random_pseudo_bytes(openssl_cipher_iv_length('AES-256-GCM')));
        #Using array, in case some other settings will be required in the future
        $cryptoSettings = ['passphrase' => $passphrase];
        #Write config file
        file_put_contents(Common::$securityCache. '/aes.json', json_encode($cryptoSettings, JSON_PRETTY_PRINT));
        return $cryptoSettings;
    }

    #Function to log actions
    public static function log(string $type, string $action, mixed $extras = NULL, ?int $userid = null): bool
    {
        if (!empty($extras)) {
            $extras = json_encode($extras, JSON_PRETTY_PRINT|JSON_INVALID_UTF8_SUBSTITUTE|JSON_UNESCAPED_UNICODE|JSON_PRESERVE_ZERO_FRACTION);
        }
        #Get IP
        $ip = $_SESSION['IP'] ?? null;
        #Get username
        $userid = $_SESSION['userid'] ?? $userid ?? Talks::userIDs['Unknown user'];
        #Get User Agent
        $ua = $_SESSION['UA']['full'] ?? null;
        try {
            if (!is_null(HomePage::$dbController)) {
                HomePage::$dbController->query(
                    'INSERT INTO `sys__logs` (`time`, `type`, `action`, `userid`, `ip`, `useragent`, `extra`) VALUES (CURRENT_TIMESTAMP(), (SELECT `typeid` FROM `sys__log_types` WHERE `name`=:type), :action, :userid, :ip, :ua, :extras);',
                    [
                        ':type' => $type,
                        ':action' => $action,
                        ':userid' => [$userid,'int'],
                        ':ip' => [
                            (empty($ip) ? NULL : $ip),
                            (empty($ip) ? 'null' : 'string'),
                        ],
                        ':ua' => [
                            (empty($ua) ? NULL : $ua),
                            (empty($ua) ? 'null' : 'string'),
                        ],
                        ':extras' => [
                            (empty($extras) ? NULL : $extras),
                            (empty($extras) ? 'null' : 'string'),
                        ],
                    ]
                );
                return true;
            } else {
                return false;
            }
        } catch (\Throwable $exception) {
            #Just log to file. Generally we do not lose much if this fails
            Errors::error_log($exception);
            return false;
        }
    }
}
