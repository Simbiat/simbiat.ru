<?php
declare(strict_types=1);
namespace Simbiat;

use DeviceDetector\ClientHints;
use DeviceDetector\DeviceDetector;
use DeviceDetector\Parser\AbstractParser;
use DeviceDetector\Parser\Device\AbstractDeviceParser;
use Simbiat\Config\Common;
use Simbiat\Config\Talks;
use Symfony\Component\HtmlSanitizer\HtmlSanitizerConfig;

class Security
{

    #Static sanitizer config for a little bit performance
    
    #Function to hash password. Used mostly as a wrapper in case of future changes
    public static function passHash(string $password): string
    {
        return password_hash($password, PASSWORD_ARGON2ID, Config\Security::$argonSettings);
    }

    #Function to encrypt stuff
    public static function encrypt(string $data): string
    {
        if (empty($data)) {
            return '';
        }
        #Generate IV
        $iv = openssl_random_pseudo_bytes(openssl_cipher_iv_length('AES-256-GCM'));
        #This is where tag will be written by OpenSSL
        $tag = '';
        #Ecnrypt and als get the tag
        $encrypted = openssl_encrypt($data, 'AES-256-GCM', hex2bin(Config\Security::$aesSettings['passphrase']), OPENSSL_RAW_DATA, $iv, $tag);
        #Ecnrypt and prepend IV and tag
        return base64_encode($iv.$tag.$encrypted);
    }

    #Function to decrypt stuff
    public static function decrypt(string $data): string
    {
        if (empty($data)) {
            return '';
        }
        #Decode
        $data = base64_decode($data);
        #Get IV
        $iv = substr($data, 0, 12);
        #Get tag
        $tag = substr($data, 12, 16);
        #Strip them from data
        $data = substr($data, 28);
        return openssl_decrypt($data, 'AES-256-GCM', hex2bin(Config\Security::$aesSettings['passphrase']), OPENSSL_RAW_DATA, $iv, $tag);
    }

    #Function to generate tokens (for example CSRF)
    public static function genToken(): string
    {
        try {
            $token = bin2hex(random_bytes(32));
        } catch (\Throwable) {
            $token = '';
        }
        @header('X-CSRF-Token: '.$token);
        return $token;
    }

    #Function to calculate optimal parameters for Argon2 hashing (password used is just a random test one) or return existing ones.
    #Clarification for whoever reads this: while it is recommended to first allocate as much memory as possible and then increase the number of iterations, if this logic is applied to a high-load web-server it will become highly likely to get the memory exhaustion during concurrent runs of the validation. Thus, this automated function first calculates the number of iterations and then memory.
    #This does not necessarily mean reduction of security, but if you feel unsafe, adjust the setting file generated by this function to settings that work better for you. Keep in mind, that amount of memory is recommended to be a value of power of 2 (1024 is the minimum one).
    public static function argonCalc(bool $forceRefresh = false): array
    {
        #Load Argon settings if argon.json exists
        if (is_file(Config\Common::$securityCache. '/argon.json') && !$forceRefresh) {
            #Read the file
            $argon = json_decode(file_get_contents(Config\Common::$securityCache. '/argon.json'), true);
            if (is_array($argon)) {
                #Update settings, if they are present and comply with minimum requirements
                if (!isset($argon['memory_cost']) || $argon['memory_cost'] < 1024) {
                    $argon['memory_cost'] = 1024;
                }
                if (!isset($argon['time_cost']) || $argon['time_cost'] < 1) {
                    $argon['time_cost'] = 1;
                }
                if (!isset($argon['threads']) || $argon['threads'] < 1) {
                    $argon['threads'] = 1;
                }
                return $argon;
            }
        }
        #Create directory if missing
        if (!is_dir(Common::$securityCache)) {
            mkdir(Common::$securityCache);
        }
        #Calculate number of available threads
        $threads = self::countCores()*2;
        #Calculate iterations
        $iterations = 0;
        do {
            $iterations++;
            $start = microtime(true);
            password_hash('rel@t!velyl0ngte$t5tr1ng', PASSWORD_ARGON2ID, ['threads' => $threads, 'time_cost' => $iterations]);
            $end = microtime(true);
        } while (($end - $start) < 1.0);
        #Calculate memory. We start from power = 9, because Argon supports minimum value of 1024 (power = 10)
        $power = 9;
        do {
            $power++;
            $memory = 2**$power;
            $start = microtime(true);
            password_hash('rel@t!velyl0ngte$t5tr1ng', PASSWORD_ARGON2ID, ['threads' => $threads, 'time_cost' => $iterations, 'memory_cost' => $memory]);
            $end = microtime(true);
        } while (($end - $start) < 1.0);
        $argonSettings = ['threads' => $threads, 'time_cost' => $iterations, 'memory_cost' => $memory];
        #Write config file
        file_put_contents(Common::$securityCache.'/argon.json', json_encode($argonSettings, JSON_PRETTY_PRINT));
        return $argonSettings;
    }

    #Helper function to get count of available cores
    private static function countCores(): int
    {
        if (function_exists('shell_exec') === true) {
            $cores = intval(shell_exec((PHP_OS_FAMILY === 'Windows' ? 'echo %NUMBER_OF_PROCESSORS%' : 'nproc')));
        } else {
            $cores = 1;
        }
        if ($cores < 1) {
            $cores = 1;
        }
        return $cores;
    }

    #Function to generate passphrase for encrypt and decrypt functions
    public static function genCrypto(bool $forceRefresh = false): array
    {
        if (is_file(Config\Common::$securityCache. '/aes.json') && !$forceRefresh) {
            $aes = json_decode(file_get_contents(Config\Common::$securityCache.'/aes.json'), true);
            if (is_array($aes)) {
                if (isset($aes['passphrase'])) {
                    return $aes;
                }
            }
        }
        #Create directory if missing
        if (!is_dir(Common::$securityCache)) {
            mkdir(Common::$securityCache);
        }
        $passphrase = bin2hex(openssl_random_pseudo_bytes(openssl_cipher_iv_length('AES-256-GCM')));
        #Using array, in case some other settings will be required in the future
        $cryptoSettings = ['passphrase' => $passphrase];
        #Write config file
        file_put_contents(Common::$securityCache. '/aes.json', json_encode($cryptoSettings, JSON_PRETTY_PRINT));
        return $cryptoSettings;
    }

    #Function to log actions
    public static function log(string $type, string $action, mixed $extras = NULL, ?int $userid = null): bool
    {
        if (!empty($extras)) {
            $extras = json_encode($extras, JSON_PRETTY_PRINT|JSON_INVALID_UTF8_SUBSTITUTE|JSON_UNESCAPED_UNICODE|JSON_PRESERVE_ZERO_FRACTION);
        }
        #Get IP
        $ip = $_SESSION['IP'] ?? null;
        #Get username
        $userid = $_SESSION['userid'] ?? $userid ?? Talks::userIDs['Unknown user'];
        #Get User Agent
        $ua = $_SESSION['UA']['full'] ?? null;
        try {
            if (!is_null(HomePage::$dbController)) {
                HomePage::$dbController->query(
                    'INSERT INTO `sys__logs` (`time`, `type`, `action`, `userid`, `ip`, `useragent`, `extra`) VALUES (CURRENT_TIMESTAMP(), (SELECT `typeid` FROM `sys__log_types` WHERE `name`=:type), :action, :userid, :ip, :ua, :extras);',
                    [
                        ':type' => $type,
                        ':action' => $action,
                        ':userid' => [$userid,'int'],
                        ':ip' => [
                            (empty($ip) ? NULL : $ip),
                            (empty($ip) ? 'null' : 'string'),
                        ],
                        ':ua' => [
                            (empty($ua) ? NULL : $ua),
                            (empty($ua) ? 'null' : 'string'),
                        ],
                        ':extras' => [
                            (empty($extras) ? NULL : $extras),
                            (empty($extras) ? 'null' : 'string'),
                        ],
                    ]
                );
                return true;
            } else {
                return false;
            }
        } catch (\Throwable $exception) {
            #Just log to file. Generally we do not lose much if this fails
            Errors::error_log($exception);
            return false;
        }
    }
    
    #Get Bot name, OS and Browser for user agent
    public static function getUA(): array
    {
        #Check if User Agent is present
        if (empty($_SERVER['HTTP_USER_AGENT'])) {
            #Something is fishy, so let's 418 this
            return ['unsupported' => true, 'browser' => false];
        }
        #Force full versions
        AbstractDeviceParser::setVersionTruncation(AbstractParser::VERSION_TRUNCATION_NONE);
        #Initialize device detector
        $dd = (new DeviceDetector($_SERVER['HTTP_USER_AGENT'], ClientHints::factory($_SERVER)));
        $dd->parse();
        #Get bot name
        $bot = $dd->getBot();
        if ($bot !== NULL) {
            #Do not waste resources on bots
            return ['bot' => substr($bot['name'], 0, 64), 'os' => NULL, 'client' => NULL, 'unsupported' => false, 'browser' => false];
        }
        #Get OS
        $os = $dd->getOs();
        #Concat OS and version
        $os = trim(($os['name'] ?? '').' '.($os['version'] ?? ''));
        #Force OS to be NULL, if it's empty
        if (empty($os)) {
            $os = NULL;
        }
        #Get client
        $browser = $dd->isBrowser();
        $client = $dd->getClient();
        #Check if client is supported
        if (preg_match('/^(Internet Explorer|Opera Mini|Opera Mobile|Baidu|UC Browser|QQ Browser|KaiOS Browser).*/ui', $client['name'] ?? '') === 1 ||
            (!empty($client['version']) && (
                #Safari started supporting Sec-Fetch from 16.4
                (preg_match('/^(Safari).*/ui', $client['name'] ?? '') === 1 && version_compare(strtolower($client['version']), '16.4', 'lt')) ||
                #Similar for Chrome and Edge, but full support started from 80
                (preg_match('/^(Chrome).*/ui', $client['name'] ?? '') === 1 && version_compare(strtolower($client['version']), '80.0', 'lt')) ||
                (preg_match('/^(Edge).*/ui', $client['name'] ?? '') === 1 && version_compare(strtolower($client['version']), '80.0', 'lt')) ||
                #Version 90 for Firefox
                (preg_match('/^(Firefox).*/ui', $client['name'] ?? '') === 1 && version_compare(strtolower($client['version']), '90.0', 'lt')) ||
                #Version 67 for Opera
                (preg_match('/^(Opera).*/ui', $client['name'] ?? '') === 1 && version_compare(strtolower($client['version']), '67.0', 'lt'))
            ))
        ) {
            $unsupported = true;
        } else {
            $unsupported = false;
        }
        #Concat client and version
        $client = trim(($client['name'] ?? '').' '.($client['version'] ?? ''));
        #Force client to be NULL, if it's empty
        if (empty($client)) {
            $client = NULL;
        }
        return ['bot' => NULL, 'os' => ($os !== NULL ? substr($os, 0, 100) : NULL), 'client' => ($client !== NULL ? substr($client, 0, 100) : NULL), 'full' => $_SERVER['HTTP_USER_AGENT'], 'unsupported' => $unsupported, 'browser' => $browser];
    }
}
